})
return(0)
}
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out<-tryCatch(model1 <- raw_model(data),
error=function(c){
print("raw model")
return(1)
})
out<tryCatch(model2 <- cgm_model(cgm_cent(data)),
error=function(c){
print("cgm model")
return(1)
})
out<tryCatch(model3 <- cwc_model(cwc_cent(data)),
error=function(c){
print("cwc model")
return(1)
})
return(out)
}
set.seed(7)
simulation_run()
generate_data<-function(group_size, num_groups,ICC,corr,gamma, checkConv=TRUE){
meanx1<-0.1 #rnorm(1) variance is higher than mean
meanx2<-1.1 #rnorm(1) variance is lower than mean
sigma1 <- matrix(c(1,corr,corr,1),2,2) #generating cov matrix
x1x2<-mvrnorm(n=group_size*num_groups, mu = c(meanx1,meanx2), Sigma=sigma1)
x1<-x1x2[,1] # generating level 1 predictors
x2<-x1x2[,2]
cor(x1,x2)
g01<-rnorm(num_groups) # generating level 2 predictors
g02<-rnorm(num_groups)
id<-rep(1:(group_size*num_groups)) # generating id
g_id <- as.factor(rep(1:num_groups, each = group_size))
g1<-rep(g01, each = group_size)
g2<-rep(g02, each = group_size)
X<-cbind(id,g_id,x1,x2,g1,g2) # generating matrix
varL1 <- 1 # variances on levels 1 and 2
varL2 <-ICC/(1-ICC)
#cov = cor*sqrt(var1*var2) = cor*sqrt(var2^2) = cor*var2
sigma_u <- rbind(c(varL2,0*varL2,0*varL2), c(0*varL2,varL2,0*varL2), c(0*varL2,0*varL2,varL2))
u <- mvrnorm(n=num_groups, mu=c(0,0,0), Sigma = sigma_u)
u0j<-u[,1]
u1j<-u[,2]
u2j<-u[,3]
beta0j <- rep(gamma[["gamma00"]],num_groups) + gamma[["gamma01"]]*g01 + gamma[["gamma02"]]*g02 + u0j # betas
beta1j <- rep(gamma[["gamma10"]],num_groups) + gamma[["gamma11"]]*g01 + gamma[["gamma12"]]*g02 + u1j
beta2j <- rep(gamma[["gamma20"]],num_groups) + gamma[["gamma21"]]*g01 + gamma[["gamma22"]]*g02 + u2j
eps<-rnorm(group_size*num_groups)
y<-1+beta0j+beta1j*x1+beta2j*x2+eps
data1 <- data.frame(y, x1, x2, g_id, g1, g2)
# check convergence and rerun recursively if not met for one of the models
if(conv_check(data1)){
repeat{
data1<-generate_data(group_size, num_groups, ICC,corr,gamma)
if(!conv_check(data1)){
break
}
}
}
return(data1)
}
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
force(checkConv)
conv_check<-function(data){
out<-tryCatch(model1 <- raw_model(data),
error=function(c){
print("raw model")
return(0)
})
out<tryCatch(model2 <- cgm_model(cgm_cent(data)),
error=function(c){
print("cgm model")
return(0)
})
out<tryCatch(model3 <- cwc_model(cwc_cent(data)),
error=function(c){
print("cwc model")
return(0)
})
return(out)
}
generate_data<-function(group_size, num_groups,ICC,corr,gamma, checkConv=TRUE){
meanx1<-0.1 #rnorm(1) variance is higher than mean
meanx2<-1.1 #rnorm(1) variance is lower than mean
sigma1 <- matrix(c(1,corr,corr,1),2,2) #generating cov matrix
x1x2<-mvrnorm(n=group_size*num_groups, mu = c(meanx1,meanx2), Sigma=sigma1)
x1<-x1x2[,1] # generating level 1 predictors
x2<-x1x2[,2]
cor(x1,x2)
g01<-rnorm(num_groups) # generating level 2 predictors
g02<-rnorm(num_groups)
id<-rep(1:(group_size*num_groups)) # generating id
g_id <- as.factor(rep(1:num_groups, each = group_size))
g1<-rep(g01, each = group_size)
g2<-rep(g02, each = group_size)
X<-cbind(id,g_id,x1,x2,g1,g2) # generating matrix
varL1 <- 1 # variances on levels 1 and 2
varL2 <-ICC/(1-ICC)
#cov = cor*sqrt(var1*var2) = cor*sqrt(var2^2) = cor*var2
sigma_u <- rbind(c(varL2,0*varL2,0*varL2), c(0*varL2,varL2,0*varL2), c(0*varL2,0*varL2,varL2))
u <- mvrnorm(n=num_groups, mu=c(0,0,0), Sigma = sigma_u)
u0j<-u[,1]
u1j<-u[,2]
u2j<-u[,3]
beta0j <- rep(gamma[["gamma00"]],num_groups) + gamma[["gamma01"]]*g01 + gamma[["gamma02"]]*g02 + u0j # betas
beta1j <- rep(gamma[["gamma10"]],num_groups) + gamma[["gamma11"]]*g01 + gamma[["gamma12"]]*g02 + u1j
beta2j <- rep(gamma[["gamma20"]],num_groups) + gamma[["gamma21"]]*g01 + gamma[["gamma22"]]*g02 + u2j
eps<-rnorm(group_size*num_groups)
y<-1+beta0j+beta1j*x1+beta2j*x2+eps
data1 <- data.frame(y, x1, x2, g_id, g1, g2)
# check convergence and rerun recursively if not met for one of the models
if(!conv_check(data1)){
repeat{
data1<-generate_data(group_size, num_groups, ICC,corr,gamma)
if(conv_check(data1)){
break
}
}
}
return(data1)
}
simulation_run<- function(){
start.time <- Sys.time()
### preparing and saving raw data
raw.data<-generate_data(group_size, num_groups, ICC,corr,gamma)
suppressWarnings(write.table(data.frame(raw.data,row.names = NULL), "./data/rawdata.csv", sep = ",", col.names = !file.exists("rawdata.csv"), append = T))
### raw model
raw.res<-raw_model(raw.data,gamma)
raw.coef<-raw.res[,1]
suppressWarnings(write.table(data.frame(t(raw.coef),row.names = NULL), "./data/raw_coef.csv", sep = ",", col.names = !file.exists("raw_coef.csv"), append = T))
raw.se<-raw.res[,2]
suppressWarnings(write.table(data.frame(t(raw.se),row.names = NULL), "./data/raw_se.csv", sep = ",", col.names = !file.exists("raw_se.csv"), append = T))
### cgm model
cgm.data<-cgm_cent(raw.data)
cgm.res<-cgm_model(cgm.data,gamma)
cgm.coef<-cgm.res[,1]
suppressWarnings(write.table(data.frame(t(cgm.coef),row.names = NULL), "./data/cgm_coef.csv", sep = ",", col.names = !file.exists("cgm_coef.csv"), append = T))
cgm.se<-cgm.res[,2]
suppressWarnings(write.table(data.frame(t(cgm.se),row.names = NULL), "./data/cgm_se.csv", sep = ",", col.names = !file.exists("cgm_se.csv"), append = T))
### cwc model
cwc.data<-cwc_cent(raw.data)
cwc.res<-cwc_model(cwc.data,gamma)
cwc.coef<-cwc.res[,1]
suppressWarnings(write.table(data.frame(t(cwc.coef),row.names = NULL), "./data/cwc_coef.csv", sep = ",", col.names = !file.exists("cwc_coef.csv"), append = T))
cwc.se<-cwc.res[,2]
suppressWarnings(write.table(data.frame(t(cwc.se),row.names = NULL), "./data/cwc_se.csv", sep = ",", col.names = !file.exists("cwc_se.csv"), append = T))
end.time <- Sys.time()
time.taken <- end.time - start.time
print(paste0("Simulation finished. Time taken: ",round(time.taken,3), "s"))
return(0)
}
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out<-tryCatch(len(raw_model(data)),
error=function(c){
print("raw model")
return(0)
})
out<tryCatch(len(cgm_model(cgm_cent(data))),
error=function(c){
print("cgm model")
return(0)
})
out<tryCatch(len(cwc_model(cwc_cent(data))),
error=function(c){
print("cwc model")
return(0)
})
return(out)
}
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out<-tryCatch(len(raw_model(data)),
error=function(c){
print("raw model")
return(0)
})
out<-tryCatch(len(cgm_model(cgm_cent(data))),
error=function(c){
print("cgm model")
return(0)
})
out<-tryCatch(len(cwc_model(cwc_cent(data))),
error=function(c){
print("cwc model")
return(0)
})
return(out)
}
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
break
generate_data<-function(group_size, num_groups,ICC,corr,gamma, checkConv=TRUE){
meanx1<-0.1 #rnorm(1) variance is higher than mean
meanx2<-1.1 #rnorm(1) variance is lower than mean
sigma1 <- matrix(c(1,corr,corr,1),2,2) #generating cov matrix
x1x2<-mvrnorm(n=group_size*num_groups, mu = c(meanx1,meanx2), Sigma=sigma1)
x1<-x1x2[,1] # generating level 1 predictors
x2<-x1x2[,2]
cor(x1,x2)
g01<-rnorm(num_groups) # generating level 2 predictors
g02<-rnorm(num_groups)
id<-rep(1:(group_size*num_groups)) # generating id
g_id <- as.factor(rep(1:num_groups, each = group_size))
g1<-rep(g01, each = group_size)
g2<-rep(g02, each = group_size)
X<-cbind(id,g_id,x1,x2,g1,g2) # generating matrix
varL1 <- 1 # variances on levels 1 and 2
varL2 <-ICC/(1-ICC)
#cov = cor*sqrt(var1*var2) = cor*sqrt(var2^2) = cor*var2
sigma_u <- rbind(c(varL2,0*varL2,0*varL2), c(0*varL2,varL2,0*varL2), c(0*varL2,0*varL2,varL2))
u <- mvrnorm(n=num_groups, mu=c(0,0,0), Sigma = sigma_u)
u0j<-u[,1]
u1j<-u[,2]
u2j<-u[,3]
beta0j <- rep(gamma[["gamma00"]],num_groups) + gamma[["gamma01"]]*g01 + gamma[["gamma02"]]*g02 + u0j # betas
beta1j <- rep(gamma[["gamma10"]],num_groups) + gamma[["gamma11"]]*g01 + gamma[["gamma12"]]*g02 + u1j
beta2j <- rep(gamma[["gamma20"]],num_groups) + gamma[["gamma21"]]*g01 + gamma[["gamma22"]]*g02 + u2j
eps<-rnorm(group_size*num_groups)
y<-1+beta0j+beta1j*x1+beta2j*x2+eps
data1 <- data.frame(y, x1, x2, g_id, g1, g2)
# check convergence and rerun recursively if not met for one of the models
if(!conv_check(data1)){
repeat{
data1<-generate_data(group_size, num_groups, ICC,corr,gamma)
if(conv_check(data1)){
break
}
}
}
return(data1)
}
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
generate_data<-function(group_size, num_groups,ICC,corr,gamma, checkConv=TRUE){
meanx1<-0.1 #rnorm(1) variance is higher than mean
meanx2<-1.1 #rnorm(1) variance is lower than mean
sigma1 <- matrix(c(1,corr,corr,1),2,2) #generating cov matrix
x1x2<-mvrnorm(n=group_size*num_groups, mu = c(meanx1,meanx2), Sigma=sigma1)
x1<-x1x2[,1] # generating level 1 predictors
x2<-x1x2[,2]
cor(x1,x2)
g01<-rnorm(num_groups) # generating level 2 predictors
g02<-rnorm(num_groups)
id<-rep(1:(group_size*num_groups)) # generating id
g_id <- as.factor(rep(1:num_groups, each = group_size))
g1<-rep(g01, each = group_size)
g2<-rep(g02, each = group_size)
X<-cbind(id,g_id,x1,x2,g1,g2) # generating matrix
varL1 <- 1 # variances on levels 1 and 2
varL2 <-ICC/(1-ICC)
#cov = cor*sqrt(var1*var2) = cor*sqrt(var2^2) = cor*var2
sigma_u <- rbind(c(varL2,0*varL2,0*varL2), c(0*varL2,varL2,0*varL2), c(0*varL2,0*varL2,varL2))
u <- mvrnorm(n=num_groups, mu=c(0,0,0), Sigma = sigma_u)
u0j<-u[,1]
u1j<-u[,2]
u2j<-u[,3]
beta0j <- rep(gamma[["gamma00"]],num_groups) + gamma[["gamma01"]]*g01 + gamma[["gamma02"]]*g02 + u0j # betas
beta1j <- rep(gamma[["gamma10"]],num_groups) + gamma[["gamma11"]]*g01 + gamma[["gamma12"]]*g02 + u1j
beta2j <- rep(gamma[["gamma20"]],num_groups) + gamma[["gamma21"]]*g01 + gamma[["gamma22"]]*g02 + u2j
eps<-rnorm(group_size*num_groups)
y<-1+beta0j+beta1j*x1+beta2j*x2+eps
data1 <- data.frame(y, x1, x2, g_id, g1, g2)
# check convergence and rerun recursively if not met for one of the models
if(conv_check(data1)==0){
repeat{
data1<-generate_data(group_size, num_groups, ICC,corr,gamma)
if(conv_check(data1)>0){
break
}
}
}
return(data1)
}
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out<-tryCatch(len(raw_model(data)),
error=function(c){
print("raw model")
return(0)
})
out<-tryCatch(len(cgm_model(cgm_cent(data))),
error=function(c){
print("cgm model")
return(0)
})
out<-tryCatch(len(cwc_model(cwc_cent(data))),
error=function(c){
print("cwc model")
return(0)
})
return(out)
}
generate_data<-function(group_size, num_groups,ICC,corr,gamma, checkConv=TRUE){
meanx1<-0.1 #rnorm(1) variance is higher than mean
meanx2<-1.1 #rnorm(1) variance is lower than mean
sigma1 <- matrix(c(1,corr,corr,1),2,2) #generating cov matrix
x1x2<-mvrnorm(n=group_size*num_groups, mu = c(meanx1,meanx2), Sigma=sigma1)
x1<-x1x2[,1] # generating level 1 predictors
x2<-x1x2[,2]
cor(x1,x2)
g01<-rnorm(num_groups) # generating level 2 predictors
g02<-rnorm(num_groups)
id<-rep(1:(group_size*num_groups)) # generating id
g_id <- as.factor(rep(1:num_groups, each = group_size))
g1<-rep(g01, each = group_size)
g2<-rep(g02, each = group_size)
X<-cbind(id,g_id,x1,x2,g1,g2) # generating matrix
varL1 <- 1 # variances on levels 1 and 2
varL2 <-ICC/(1-ICC)
#cov = cor*sqrt(var1*var2) = cor*sqrt(var2^2) = cor*var2
sigma_u <- rbind(c(varL2,0*varL2,0*varL2), c(0*varL2,varL2,0*varL2), c(0*varL2,0*varL2,varL2))
u <- mvrnorm(n=num_groups, mu=c(0,0,0), Sigma = sigma_u)
u0j<-u[,1]
u1j<-u[,2]
u2j<-u[,3]
beta0j <- rep(gamma[["gamma00"]],num_groups) + gamma[["gamma01"]]*g01 + gamma[["gamma02"]]*g02 + u0j # betas
beta1j <- rep(gamma[["gamma10"]],num_groups) + gamma[["gamma11"]]*g01 + gamma[["gamma12"]]*g02 + u1j
beta2j <- rep(gamma[["gamma20"]],num_groups) + gamma[["gamma21"]]*g01 + gamma[["gamma22"]]*g02 + u2j
eps<-rnorm(group_size*num_groups)
y<-1+beta0j+beta1j*x1+beta2j*x2+eps
data1 <- data.frame(y, x1, x2, g_id, g1, g2)
# check convergence and rerun recursively if not met for one of the models
if(conv_check(data1)==0){
repeat{
data1<-generate_data(group_size, num_groups, ICC,corr,gamma)
if(conv_check(data1)>0){
break
}
}
}
return(data1)
}
set.seed(7)
simulation_run()
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out<-tryCatch(raw_model(data),
error=function(c){
print("raw model")
return(0)
})
out<-tryCatch(cgm_model(cgm_cent(data)),
error=function(c){
print("cgm model")
return(0)
})
out<-tryCatch(cwc_model(cwc_cent(data)),
error=function(c){
print("cwc model")
return(0)
})
return(out)
}
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out<-tryCatch(length(raw_model(data)),
error=function(c){
print("raw model")
return(0)
})
out<-tryCatch(length(cgm_model(cgm_cent(data))),
error=function(c){
print("cgm model")
return(0)
})
out<-tryCatch(length(cwc_model(cwc_cent(data))),
error=function(c){
print("cwc model")
return(0)
})
return(out)
}
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out_raw<-tryCatch(length(raw_model(data)),
error=function(c){
print("raw model")
return(0)
})
out_cgm<-tryCatch(length(cgm_model(cgm_cent(data))),
error=function(c){
print("cgm model")
return(0)
})
out_cwc<-tryCatch(length(cwc_model(cwc_cent(data))),
error=function(c){
print("cwc model")
return(0)
})
if (out_raw == 0 | out_cgm == 0 | out_cwc == 0){
return(0)
}
else{
return(1)
}
}
debugSource("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
set.seed(7)
simulation_run()
source("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
simulation_run()
conv_check<-function(data){
out_raw<-tryCatch(length(raw_model(data)),
error=function(c){
print("Raw model is not converging. Restarting simulation")
return(0)
})
out_cgm<-tryCatch(length(cgm_model(cgm_cent(data))),
error=function(c){
print("Cgm model is not converging. Restarting simulation")
return(0)
})
out_cwc<-tryCatch(length(cwc_model(cwc_cent(data))),
error=function(c){
print("Cwc modelis not converging. Restarting simulation")
return(0)
})
if (out_raw == 0 | out_cgm == 0 | out_cwc == 0){
return(0)
}
else{
return(1)
}
}
set.seed(7)
simulation_run()
replicate(n = 100, simulation_run(),simplify = FALSE)
set.seed(7)
generate_data(group_size=10, num_groups=50, ICC=0.3,corr=0.7,gamma=rep(1,9))
generate_data<-function(group_size, num_groups,ICC,corr,gamma, checkConv=TRUE){
names(gamma)<-c("gamma00", "gamma01", "gamma02", "gamma10","gamma11","gamma12","gamma20", "gamma21", "gamma22")
meanx1<-0.1 #rnorm(1) variance is higher than mean
meanx2<-1.1 #rnorm(1) variance is lower than mean
sigma1 <- matrix(c(1,corr,corr,1),2,2) #generating cov matrix
x1x2<-mvrnorm(n=group_size*num_groups, mu = c(meanx1,meanx2), Sigma=sigma1)
x1<-x1x2[,1] # generating level 1 predictors
x2<-x1x2[,2]
cor(x1,x2)
g01<-rnorm(num_groups) # generating level 2 predictors
g02<-rnorm(num_groups)
id<-rep(1:(group_size*num_groups)) # generating id
g_id <- as.factor(rep(1:num_groups, each = group_size))
g1<-rep(g01, each = group_size)
g2<-rep(g02, each = group_size)
X<-cbind(id,g_id,x1,x2,g1,g2) # generating matrix
varL1 <- 1 # variances on levels 1 and 2
varL2 <-ICC/(1-ICC)
#cov = cor*sqrt(var1*var2) = cor*sqrt(var2^2) = cor*var2
sigma_u <- rbind(c(varL2,0*varL2,0*varL2), c(0*varL2,varL2,0*varL2), c(0*varL2,0*varL2,varL2))
u <- mvrnorm(n=num_groups, mu=c(0,0,0), Sigma = sigma_u)
u0j<-u[,1]
u1j<-u[,2]
u2j<-u[,3]
beta0j <- rep(gamma[["gamma00"]],num_groups) + gamma[["gamma01"]]*g01 + gamma[["gamma02"]]*g02 + u0j # betas
beta1j <- rep(gamma[["gamma10"]],num_groups) + gamma[["gamma11"]]*g01 + gamma[["gamma12"]]*g02 + u1j
beta2j <- rep(gamma[["gamma20"]],num_groups) + gamma[["gamma21"]]*g01 + gamma[["gamma22"]]*g02 + u2j
eps<-rnorm(group_size*num_groups)
y<-1+beta0j+beta1j*x1+beta2j*x2+eps
data1 <- data.frame(y, x1, x2, g_id, g1, g2)
# check convergence and rerun recursively if not met for one of the models
if(conv_check(data1) == 0){
repeat{
data1<-generate_data(group_size, num_groups, ICC,corr,gamma)
if(conv_check(data1)>0){
break
}
}
}
return(data1)
}
source("~/Documents/GitHub/multilevel-centering/functions.R")
set.seed(7)
generate_data(group_size=10, num_groups=50, ICC=0.3,corr=0.7,gamma=rep(1,9))
